<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeeSurf - Battle to the End</title>
    <style>
        body { margin: 0; background: #0a0a0a; color: #fff; font-family: sans-serif; overflow: hidden; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; pointer-events: none; }
        .p-box { text-align: center; width: 300px; }
        .bar-container { background: #222; height: 15px; width: 100%; border: 2px solid #555; border-radius: 10px; overflow: hidden; margin-top: 5px; }
        .bar { height: 100%; transition: width 0.1s; }
        #hp1 { background: #ffcc00; width: 100%; }
        #hp2 { background: #00ccff; width: 100%; }
        #overlay { 
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 50px; text-align: center; border: 2px solid #fff;
        }
        button { padding: 10px 20px; font-size: 18px; cursor: pointer; background: #ffcc00; border: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="p-box">
            <div style="color:#ffcc00; font-weight:bold;">PLAYER 1</div>
            <div class="bar-container"><div id="hp1" class="bar"></div></div>
        </div>
        <div class="p-box">
            <div style="color:#00ccff; font-weight:bold;">PLAYER 2</div>
            <div class="bar-container"><div id="hp2" class="bar"></div></div>
        </div>
    </div>
    <div id="overlay"><h1 id="msg"></h1><button onclick="location.reload()">REMATCH</button></div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let gameOver = false;

const gravity = 0.28;
const friction = 0.992;
const dashPower = 18;

function createPlayer(x, y, color, id) {
    return { id, x, y, vx: 10, vy: 0, radius: 15, color, hp: 100, dashCooldown: 0, isDashing: 0 };
}

let p1 = createPlayer(100, 300, '#ffcc00', 'P1');
let p2 = createPlayer(200, 300, '#00ccff', 'P2');

let platforms = [];
let hazards = []; // Flowers and Spikes
let nextX = 0;
let lastY = 400;

function createSegment(startX) {
    const width = 300 + Math.random() * 300;
    const gap = 200 + Math.random() * 200;
    const endY = Math.max(150, Math.min(window.innerHeight - 150, lastY + (Math.random() * 400 - 200)));
    const s = { x1: startX + gap, y1: lastY, x2: startX + gap + width, y2: endY };
    
    // Randomly add a hazard on the platform
    if (Math.random() > 0.5) {
        hazards.push({
            x: s.x1 + width/2,
            y: (s.y1 + s.y2)/2 - 30,
            type: Math.random() > 0.4 ? 'spike' : 'flower',
            collected: false
        });
    }

    lastY = endY; nextX = s.x2; return s;
}

for(let i=0; i<10; i++) platforms.push(createSegment(nextX));

function updatePlayer(p, opp, ctrl) {
    if(gameOver) return;

    if (keys[ctrl.left]) p.vx -= 0.6;
    if (keys[ctrl.right]) p.vx += 0.6;
    if (keys[ctrl.up] && p.canJump) { p.vy = -9; p.canJump = false; }
    if (keys[ctrl.dash] && p.dashCooldown <= 0) {
        p.vx += (p.vx > 0 ? 1 : -1) * dashPower;
        p.isDashing = 15; p.dashCooldown = 60;
    }

    p.vy += gravity; p.vx *= friction; p.x += p.vx; p.y += p.vy;
    if (p.dashCooldown > 0) p.dashCooldown--;
    if (p.isDashing > 0) p.isDashing--;

    // Collision
    platforms.forEach(plat => {
        if (p.x > plat.x1 && p.x < plat.x2) {
            let t = (p.x - plat.x1) / (plat.x2 - plat.x1);
            let groundY = plat.y1 + t * (plat.y2 - plat.y1);
            if (p.y + p.radius > groundY && p.y - p.radius < groundY + 30) {
                p.y = groundY - p.radius;
                let angle = Math.atan2(plat.y2 - plat.y1, plat.x2 - plat.x1);
                let speed = Math.sqrt(p.vx**2 + p.vy**2);
                p.vx = Math.cos(angle) * speed; p.vy = Math.sin(angle) * speed;
                p.canJump = true;
            }
        }
    });

    // Dash Hit
    let d = Math.hypot(p.x - opp.x, p.y - opp.y);
    if (d < p.radius + opp.radius && p.isDashing > 0) {
        opp.hp -= 10; p.isDashing = 0; p.vx *= -0.5;
    }

    // Hazard Hit
    hazards.forEach(h => {
        if (!h.collected && Math.hypot(p.x - h.x, p.y - h.y) < 30) {
            h.collected = true;
            if (h.type === 'spike') p.hp -= 15;
            else p.hp = Math.min(100, p.hp + 20);
        }
    });

    if (p.y > window.innerHeight + 500) {
        p.hp -= 20; p.x = platforms[0].x1; p.y = platforms[0].y1 - 100; p.vx = 5;
    }

    if (p.hp <= 0 && !gameOver) {
        p.hp = 0; gameOver = true;
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('msg').innerText = (p.id === 'P1' ? 'PLAYER 2' : 'PLAYER 1') + " WINS!";
    }
}

function update() {
    updatePlayer(p1, p2, { up: 'w', left: 'a', right: 'd', dash: 's' });
    updatePlayer(p2, p1, { up: 'arrowup', left: 'arrowleft', right: 'arrowright', dash: 'arrowdown' });

    let leaderX = Math.max(p1.x, p2.x);
    if (platforms[0].x2 < leaderX - 1500) platforms.shift();
    if (platforms.length < 12) platforms.push(createSegment(nextX));
    hazards = hazards.filter(h => h.x > leaderX - 1500 && !h.collected);

    document.getElementById('hp1').style.width = p1.hp + "%";
    document.getElementById('hp2').style.width = p2.hp + "%";
    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.translate(-((p1.x + p2.x)/2) + canvas.width/3, 0);

    platforms.forEach(p => {
        ctx.strokeStyle = '#333'; ctx.lineWidth = 8;
        ctx.beginPath(); ctx.moveTo(p.x1, p.y1); ctx.lineTo(p.x2, p.y2); ctx.stroke();
    });

    hazards.forEach(h => {
        ctx.fillStyle = h.type === 'spike' ? '#ff4444' : '#44ff44';
        ctx.beginPath(); ctx.arc(h.x, h.y, 8, 0, Math.PI*2); ctx.fill();
    });

    [p1, p2].forEach(p => {
        ctx.save(); ctx.translate(p.x, p.y);
        ctx.rotate(Math.atan2(p.vy, p.vx));
        ctx.fillStyle = p.dashCooldown > 40 ? '#555' : p.color;
        ctx.beginPath(); ctx.ellipse(0, 0, 18, 12, 0, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    });
}

const keys = {};
window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;
window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
window.onresize();
update();
</script>
</body>
</html>
